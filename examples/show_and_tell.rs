#![feature(ptr_metadata)]
#![feature(box_as_ptr)]
#![feature(slice_ptr_get)]

use std::{
  alloc::{Layout, alloc}, marker::PhantomData, mem::MaybeUninit, ptr::{self, Pointee, addr_of_mut}
};

// exposes the layout of slice DSTs to allocators. (would be handled with a derive proc macro)
pub trait SliceDst: Pointee<Metadata = usize> {
  type Header;
  type Element;

  // ideally generated by a proc macro
  fn addr_of_slice(ptr: *mut Self) -> *mut [Self::Element];
}

#[repr(C)]
struct DstHeader {
  some_value: u32,
}

#[repr(C)] // to be asserted by derive proc macro
struct Dst<T> {
  header: DstHeader,
  slice: [T],
}

impl<T> SliceDst for Dst<T> {
  type Header = DstHeader;

  type Element = T;

  fn addr_of_slice(ptr: *mut Self) -> *mut [Self::Element] {
    unsafe { addr_of_mut!((*ptr).slice) }
  }
}

// notably not aligned to T. this shouldn't cause any issue in at runtime,
// assuming it's only used in allocation contexts, but it's not particularly ideal to expose
// a type with an issue that glaring.
struct UnsizedMaybeUninit<T: SliceDst + ?Sized> {
  phantom: PhantomData<T>,
  // contains T's byte representation
  _inaccessible_slice: [MaybeUninit<u8>],
}

impl<T: SliceDst + ?Sized> UnsizedMaybeUninit<T> {
  fn as_mut_ptr(ptr: *mut Self) -> *mut T {
    let (ptr, size): (*mut (), usize) = ptr.to_raw_parts();

    let element_count = (size - size_of::<T::Header>()) / size_of::<T::Element>();

    std::ptr::from_raw_parts_mut(ptr, element_count)
  }

  pub unsafe fn assume_init(this: Box<Self>) -> Box<T> {
    // does pretty much the same thing as Box::assume_init
    unsafe { Box::from_raw(Self::as_mut_ptr(Box::into_raw(this))) }
  }

  pub fn addr_of_header(this: *mut Self) -> *mut T::Header {
    this.cast()
  }

  pub fn addr_of_slice(this: *mut Self) -> *mut [T::Element] {
    T::addr_of_slice(Self::as_mut_ptr(this))
  }
}

fn allocate_dst<T>(element_count: usize) -> Box<UnsizedMaybeUninit<Dst<T>>> {
  let header_layout = Layout::new::<DstHeader>();
  // T is always repr(C)
  let (dst_layout, _header_offset) = header_layout.extend(Layout::array::<T>(element_count).unwrap()).unwrap();

  let dst_ptr: *mut UnsizedMaybeUninit<Dst<T>> =
    unsafe { ptr::from_raw_parts_mut(alloc(dst_layout), dst_layout.size()) };

  unsafe { Box::from_raw(dst_ptr) }
}

fn main() {
  let mut uninit_dst: Box<UnsizedMaybeUninit<Dst<u32>>> = allocate_dst(8);

  let dst = unsafe {
    let uninit_dst_ptr = Box::as_mut_ptr(&mut uninit_dst);

    // initialize the header
    UnsizedMaybeUninit::addr_of_header(uninit_dst_ptr).write(DstHeader { some_value: 42 });

    // initialize the slice
    let slice_ptr = UnsizedMaybeUninit::addr_of_slice(uninit_dst_ptr);
    for index in 0..slice_ptr.len() {
      slice_ptr.get_unchecked_mut(index).write(3 + index as u32);
    }

    UnsizedMaybeUninit::assume_init(uninit_dst)
  };

  println!("the answer: {}", dst.header.some_value);

  for (index, value) in dst.slice.iter().enumerate() {
    println!("slice value {index}: {value}");
  }
}
